---
/**
 * Logo 3D Component - Interactive Three.js 3D Logo with Dithering Shader
 * Displays the logo-3d.glb model with post-processing dithering effect
 * Based on: https://github.com/niccolofanton/dithering-shader
 */

interface Props {
  class?: string;
}

const { class: className = '' } = Astro.props;
---

<div class={`logo-3d ${className}`} id="logo-3d-container">
  <canvas id="logo-3d-canvas"></canvas>
</div>

<style>
  .logo-3d {
    width: 100%;
    height: 200px;
    position: relative;
    margin-inline: auto;
    cursor: pointer;
  }

  #logo-3d-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';

  // Dithering Shader - based on https://www.shadertoy.com/view/ltSSzW
  const DitheringShader = {
    uniforms: {
      'tDiffuse': { value: null },
      'resolution': { value: new THREE.Vector2() },
      'gridSize': { value: 4.0 },
      'pixelSizeRatio': { value: 1.0 },
      'grayscaleOnly': { value: 1.0 },
      'invertColor': { value: 0.0 }
    },

    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,

    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform vec2 resolution;
      uniform float gridSize;
      uniform float pixelSizeRatio;
      uniform float grayscaleOnly;
      uniform float invertColor;
      
      varying vec2 vUv;

      bool getValue(float brightness, vec2 pos) {
        if (brightness > 16.0 / 17.0) return false;
        if (brightness < 1.0 / 17.0) return true;
        
        vec2 pixel = floor(mod(pos.xy / gridSize, 4.0));
        int x = int(pixel.x);
        int y = int(pixel.y);
        
        if (x == 0) {
          if (y == 0) return brightness < 16.0 / 17.0;
          if (y == 1) return brightness < 5.0 / 17.0;
          if (y == 2) return brightness < 13.0 / 17.0;
          return brightness < 1.0 / 17.0;
        } 
        else if (x == 1) {
          if (y == 0) return brightness < 8.0 / 17.0;
          if (y == 1) return brightness < 12.0 / 17.0;
          if (y == 2) return brightness < 4.0 / 17.0;
          return brightness < 9.0 / 17.0;
        }
        else if (x == 2) {
          if (y == 0) return brightness < 14.0 / 17.0;
          if (y == 1) return brightness < 2.0 / 17.0;
          if (y == 2) return brightness < 15.0 / 17.0;
          return brightness < 3.0 / 17.0;
        }
        else {
          if (y == 0) return brightness < 6.0 / 17.0;
          if (y == 1) return brightness < 10.0 / 17.0;
          if (y == 2) return brightness < 7.0 / 17.0;
          return brightness < 11.0 / 17.0;
        }
      }

      void main() {
        vec2 fragCoord = vUv * resolution;
        
        float pixelSize = gridSize * pixelSizeRatio;
        vec2 pixelatedUV = floor(fragCoord / pixelSize) * pixelSize / resolution;
        vec4 texColor = texture2D(tDiffuse, pixelatedUV);
        vec3 baseColor = texColor.rgb;
        float alpha = texColor.a;
        
        // If alpha is 0, keep it transparent
        if (alpha < 0.01) {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
          return;
        }
        
        float luminance = dot(baseColor, vec3(1.0, 1.0, 1.0));
        
        if (grayscaleOnly > 0.0) {
          baseColor = vec3(luminance);
        }
            
        bool dithered = getValue(luminance, fragCoord);
        vec3 ditherColor = dithered ? vec3(0.0) : baseColor;
        
        vec2 currentPixel = floor(fragCoord / pixelSize);
        vec2 originalPixel = floor(vUv * resolution / pixelSize);
        
        baseColor = (currentPixel == originalPixel) ? ditherColor : baseColor;

        if (invertColor > 0.0) {
          baseColor = 1.0 - baseColor;
        }

        // Keep original alpha
        gl_FragColor = vec4(baseColor, alpha);
      }
    `
  };

  function initLogo3D() {
    const container = document.getElementById('logo-3d-container');
    const canvas = document.getElementById('logo-3d-canvas') as HTMLCanvasElement;
    
    if (!container || !canvas) return;

    // Scene setup
    const scene = new THREE.Scene();
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      45,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 5);

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ 
      canvas,
      alpha: true,
      antialias: true
    });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0); // Transparent background

    // Post-processing setup
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const ditheringPass = new ShaderPass(DitheringShader);
    ditheringPass.uniforms['resolution'].value.set(
      container.clientWidth * window.devicePixelRatio,
      container.clientHeight * window.devicePixelRatio
    );
    ditheringPass.uniforms['gridSize'].value = 3.5; // Increased for more dithering
    ditheringPass.uniforms['pixelSizeRatio'].value = 1.2; // Increased for more pixelation
    ditheringPass.uniforms['grayscaleOnly'].value = 0.0; // Keep colors
    composer.addPass(ditheringPass);

    // Hover effect - disable dithering on hover for crystal clear view
    let isHovered = false;
    let targetGridSize = 3.5;
    let targetPixelSize = 1.2;
    let currentGridSize = 3.5;
    let currentPixelSize = 1.2;
    let targetRotationY = 0;
    let targetRotationX = 0;
    let targetPositionY = 0;
    
    container.addEventListener('mouseenter', () => {
      isHovered = true;
      targetGridSize = 0.1;
      targetPixelSize = 0.1;
    });
    
    container.addEventListener('mouseleave', () => {
      isHovered = false;
      targetGridSize = 3.5;
      targetPixelSize = 1.2;
    });

    // Lighting - enhanced for better dithering effect
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
    scene.add(ambientLight);

    const directionalLight1 = new THREE.DirectionalLight(0xffffff, 2.0);
    directionalLight1.position.set(5, 5, 5);
    scene.add(directionalLight1);

    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight2.position.set(-5, -5, -5);
    scene.add(directionalLight2);

    const pointLight = new THREE.PointLight(0xffffff, 2, 100);
    pointLight.position.set(0, 5, 5);
    scene.add(pointLight);

    // Load the 3D model
    const loader = new GLTFLoader();
    let model: THREE.Group | null = null;
    let mixer: THREE.AnimationMixer | null = null;

    loader.load(
      '/logo-3d.glb',
      (gltf) => {
        model = gltf.scene;
        
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 2 / maxDim;
        
        model.scale.set(scale, scale, scale);
        model.position.sub(center.multiplyScalar(scale));
        
        // Enhanced material with gold color
        model.traverse((child) => {
          if ((child as THREE.Mesh).isMesh) {
            const mesh = child as THREE.Mesh;
            if (mesh.material) {
              const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.9,
                roughness: 0.15,
                envMapIntensity: 1.5,
              });
              mesh.material = material;
            }
          }
        });

        scene.add(model);

        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(model);
          gltf.animations.forEach((clip) => {
            mixer!.clipAction(clip).play();
          });
        }
      },
      undefined,
      (error) => {
        console.error('Error loading model:', error);
      }
    );

    let time = 0;
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      time += delta;

      if (model) {
        if (isHovered) {
          // Smoothly rotate to face user (0, 0, 0) and center position
          targetRotationY = 0;
          targetRotationX = 0;
          targetPositionY = 0;
        } else {
          // Normal animation
          targetRotationY = time * 0.3;
          targetRotationX = Math.sin(time * 0.5) * 0.1;
          targetPositionY = Math.sin(time * 0.8) * 0.15;
        }
        
        // Smooth interpolation for all transformations
        model.rotation.y += (targetRotationY - model.rotation.y) * 0.1;
        model.rotation.x += (targetRotationX - model.rotation.x) * 0.1;
        model.position.y += (targetPositionY - model.position.y) * 0.1;
      }

      if (mixer) {
        mixer.update(delta);
      }

      // Smooth transition for dithering values
      currentGridSize += (targetGridSize - currentGridSize) * 0.1;
      currentPixelSize += (targetPixelSize - currentPixelSize) * 0.1;
      ditheringPass.uniforms['gridSize'].value = currentGridSize;
      ditheringPass.uniforms['pixelSizeRatio'].value = currentPixelSize;

      // Render with post-processing
      composer.render();
    }

    animate();

    function handleResize() {
      if (!container) return;
      
      const width = container.clientWidth;
      const height = container.clientHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      composer.setSize(width, height);
      
      ditheringPass.uniforms['resolution'].value.set(
        width * window.devicePixelRatio,
        height * window.devicePixelRatio
      );
    }

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      renderer.dispose();
      composer.dispose();
      scene.clear();
    };
  }

  document.addEventListener('DOMContentLoaded', initLogo3D);
  document.addEventListener('astro:page-load', initLogo3D);
</script>
